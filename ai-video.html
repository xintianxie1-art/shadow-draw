<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>æ•°å­—çš®å½±äºº Â· çš®å½±éª¨éª¼ AI è§†é¢‘ï¼ˆA å…³èŠ‚ + B æ•´ä½“ï¼‰</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
body {
  background: #f7e9c9;
  font-family: system-ui;
  padding: 20px;
  color: #4a3a27;
}
.container {
  max-width: 900px;
  margin: auto;
  background: #fffdf6;
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 12px 32px rgba(0,0,0,0.15);
}
h1 { margin-bottom: 10px; }
label { font-size: 14px; font-weight: 600; }
input { margin: 8px 0 18px; }
#log {
  background: #1b1b1b;
  color: #eee;
  padding: 10px;
  border-radius: 8px;
  margin-top: 10px;
  height: 170px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 12px;
}
#preview {
  margin-top: 20px;
  text-align: center;
}
canvas, video {
  max-width: 100%;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.25);
}
button {
  padding: 12px 20px;
  margin-top: 8px;
  width: 100%;
  border: none;
  background: #d29a38;
  color: white;
  border-radius: 10px;
  font-size: 15px;
  cursor: pointer;
}
button:hover {
  background: #c28825;
}
small {
  display: block;
  font-size: 12px;
  color: #7b6a4a;
  margin-top: -12px;
  margin-bottom: 16px;
}
</style>
</head>
<body>

<div class="container">
  <h1>AI çš®å½±è§†é¢‘ç”Ÿæˆï¼ˆA å…³èŠ‚æ‰‹è‡‚ + B æ•´ä½“ç§»åŠ¨ï¼‰</h1>
  <p>
    ä¸ºäº†ä¿è¯â€œçš®å½±å…³èŠ‚â€ä¸ä¹±åˆ‡ï¼Œè¿™é‡Œé‡‡ç”¨ï¼š<br>
    <b>A è§’è‰² = èº«ä½“ + å·¦è‡‚ + å³è‡‚ ä¸‰å¼ é€æ˜ PNGï¼Œç”±ä½ æå‰åˆ‡å¥½ï¼›<br>
    B è§’è‰² = ä¸€æ•´å¼ é€æ˜ PNGã€‚</b><br>
    æµè§ˆå™¨æ ¹æ® A çš„é…è‰²å®æ—¶ç”Ÿæˆåœºæ™¯ï¼Œå¹¶æ§åˆ¶ A çš„è‚©å…³èŠ‚æŒ¥æ‰‹ï¼ŒB ä»å³ä¾§è¿›å…¥äº’åŠ¨ï¼Œæœ€åå½•åˆ¶ 5 ç§’è§†é¢‘ï¼ˆwebmï¼‰ã€‚
  </p>

  <label>â‘  è§’è‰² A èº«ä½“ï¼ˆbodyï¼Œä»…èº«ä½“å’Œè…¿ï¼Œå°½é‡ä¸è¦å¸¦æ‰‹è‡‚ï¼‰</label><br>
  <input id="bodyAFile" type="file" accept="image/*">
  <small>å»ºè®®åœ¨ PS é‡ŒæŠŠ A çš„æ‰‹è‡‚æŠ æ‰ï¼Œå•ç‹¬å¯¼å‡ºå·¦å³æ‰‹è‡‚ã€‚</small>

  <label>â‘¡ è§’è‰² A å·¦è‡‚ï¼ˆarmLeftï¼‰</label><br>
  <input id="armLeftAFile" type="file" accept="image/*">

  <label>â‘¢ è§’è‰² A å³è‡‚ï¼ˆarmRightï¼‰</label><br>
  <input id="armRightAFile" type="file" accept="image/*">

  <label>â‘£ è§’è‰² B æ•´ä½“ï¼ˆä¾‹å¦‚å”åƒ§ / çŒªå…«æˆ’ / æ²™åƒ§ï¼‰</label><br>
  <input id="charBFile" type="file" accept="image/*">
  <small>B ä¸åšéª¨éª¼ï¼Œåªæ•´ä½“èµ°åŠ¨ + æŠ–åŠ¨ã€‚</small>

  <button onclick="generate()">ç”Ÿæˆ AI çš®å½±è§†é¢‘ï¼ˆçº¦ 5 ç§’ï¼‰</button>

  <div id="log"></div>
  <div id="preview"></div>
</div>

<script>
// æ—¥å¿—
function log(msg) {
  const box = document.getElementById("log");
  box.innerHTML += msg + "<br>";
  box.scrollTop = box.scrollHeight;
}

// è¯»å›¾
async function loadImage(file) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.src = URL.createObjectURL(file);
  });
}

// æå–ä¸»è‰²ï¼ˆç®€å•å¹³å‡ï¼‰
function getAverageColor(img) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const size = 64;
  canvas.width = size;
  canvas.height = size;

  ctx.drawImage(img, 0, 0, size, size);
  const data = ctx.getImageData(0, 0, size, size).data;

  let r = 0, g = 0, b = 0, count = 0;
  for (let i = 0; i < data.length; i += 4) {
    const alpha = data[i + 3];
    if (alpha < 10) continue;
    r += data[i];
    g += data[i + 1];
    b += data[i + 2];
    count++;
  }
  if (!count) count = 1;
  r = Math.round(r / count);
  g = Math.round(g / count);
  b = Math.round(b / count);
  return { r, g, b };
}

function getComplementColor({ r, g, b }) {
  return { r: 255 - r, g: 255 - g, b: 255 - b };
}

function rgbStr({ r, g, b }, alpha = 1) {
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

/**
 * ç»˜åˆ¶ Aï¼šèº«ä½“ + å·¦å³æ‰‹è‡‚ï¼ˆå…³èŠ‚åœ¨è‚©éƒ¨é™„è¿‘ï¼‰
 * æ‰€æœ‰å›¾ç‰‡éƒ½å·²ç»æ˜¯ä½ æ‰‹å·¥åˆ‡å¥½çš„é€æ˜ PNGï¼Œä¸å†è‡ªåŠ¨è£åˆ‡ã€‚
 */
function drawCharacterA(ctx, bodyImg, armLeftImg, armRightImg, cx, baseY, t, phase) {
  const bodyScale = 0.7;
  const bw = bodyImg.width * bodyScale;
  const bh = bodyImg.height * bodyScale;

  const swayX = Math.sin(t * 2 * Math.PI + phase) * 4;
  const bobY  = Math.sin(t * 2 * Math.PI + phase) * 3;

  const x = cx + swayX;
  const feetY = baseY;
  const topY  = feetY - bh;

  // é˜´å½±
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "black";
  ctx.beginPath();
  ctx.ellipse(x, feetY + 4, bw * 0.4, 9, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // 1âƒ£ èº«ä½“æ•´å—ï¼ˆä¸å«æ‰‹è‡‚ï¼Œæ˜¯ä½ åˆ‡å¥½çš„ï¼‰
  ctx.drawImage(
    bodyImg,
    0, 0,
    bodyImg.width, bodyImg.height,
    x - bw / 2,
    topY + bobY,
    bw, bh
  );

  // 2âƒ£ æ‰‹è‡‚ï¼šæ ¹æ®ä½ å¯¼å‡ºçš„è‡‚å›¾ï¼Œå†ç»•è‚©è½¬åŠ¨
  const armScale = bodyScale; // ç®€å•è®¾ä¸ºä¸€æ ·çš„ç¼©æ”¾
  const awL = armLeftImg.width  * armScale;
  const ahL = armLeftImg.height * armScale;
  const awR = armRightImg.width  * armScale;
  const ahR = armRightImg.height * armScale;

  // è‚©ä½ç½®ï¼šå¤§çº¦åœ¨èº«ä½“é«˜åº¦çš„ 35%ï¼Œå·¦å³ç¨å¾®å¾€å¤–
  const shoulderCenterY = topY + bobY + bh * 0.35;
  const shoulderOffsetX = bw * 0.32; // å·¦å³è‚©ç¦»èº«ä½“ä¸­å¿ƒçš„æ°´å¹³è·ç¦»

  const leftShoulderX  = x - shoulderOffsetX;
  const rightShoulderX = x + shoulderOffsetX;

  const armAngle = Math.sin(t * 4 * Math.PI + phase) * 0.5; // Â±çº¦30Â°

  // å·¦è‡‚
  ctx.save();
  ctx.translate(leftShoulderX, shoulderCenterY);
  ctx.rotate(armAngle);
  ctx.drawImage(
    armLeftImg,
    0, 0,
    armLeftImg.width, armLeftImg.height,
    -awL * 0.2,       // è°ƒæ•´è¿™ä¸ªåç§»ï¼Œè®©è‚©éƒ¨çº¹ç†æ°å¥½è¦†ç›–åœ¨èº«ä½“è‚©çš„ä½ç½®
    0,
    awL, ahL
  );
  ctx.restore();

  // å³è‡‚
  ctx.save();
  ctx.translate(rightShoulderX, shoulderCenterY);
  ctx.rotate(-armAngle);
  ctx.drawImage(
    armRightImg,
    0, 0,
    armRightImg.width, armRightImg.height,
    -awR * 0.8,    // è¿™é‡Œå¾€å·¦åä¸€ç‚¹ï¼Œè®©è‚©ç«¯è´´ä½èº«ä½“
    0,
    awR, ahR
  );
  ctx.restore();
}

/**
 * ç»˜åˆ¶ Bï¼šæ•´ä½“ä¸€å¼ å›¾ï¼Œè½»å¾®æŠ–åŠ¨ + ç§»åŠ¨
 */
function drawCharacterB(ctx, img, cx, baseY, t, phase) {
  const scale = 0.7;
  const w = img.width * scale;
  const h = img.height * scale;

  const swayX = Math.sin(t * 2 * Math.PI + phase) * 3;
  const bobY  = Math.sin(t * 2 * Math.PI + phase) * 2;

  const x = cx + swayX;
  const feetY = baseY;
  const topY  = feetY - h;

  // é˜´å½±
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "black";
  ctx.beginPath();
  ctx.ellipse(x, feetY + 4, w * 0.4, 9, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  ctx.drawImage(
    img,
    0, 0,
    img.width, img.height,
    x - w / 2,
    topY + bobY,
    w, h
  );
}

let animId = null;

async function generate() {
  const bodyFileA    = document.getElementById("bodyAFile").files[0];
  const armLeftFileA = document.getElementById("armLeftAFile").files[0];
  const armRightFileA= document.getElementById("armRightAFile").files[0];
  const charBFile    = document.getElementById("charBFile").files[0];

  if (!bodyFileA || !armLeftFileA || !armRightFileA || !charBFile) {
    log("âŒ è¯·å…ˆä¸Šä¼ ï¼šA èº«ä½“ + A å·¦è‡‚ + A å³è‡‚ + B è§’è‰² å››å¼ å›¾");
    return;
  }

  if (animId !== null) {
    cancelAnimationFrame(animId);
    animId = null;
  }

  document.getElementById("preview").innerHTML = "";
  document.getElementById("log").innerHTML = "";

  log("âœ” åŠ è½½è§’è‰² A èº«ä½“...");
  const bodyA = await loadImage(bodyFileA);
  log("âœ” åŠ è½½è§’è‰² A å·¦è‡‚...");
  const armLeftA = await loadImage(armLeftFileA);
  log("âœ” åŠ è½½è§’è‰² A å³è‡‚...");
  const armRightA = await loadImage(armRightFileA);
  log("âœ” åŠ è½½è§’è‰² B æ•´ä½“...");
  const charB = await loadImage(charBFile);

  log("ğŸ§  æå– A èº«ä½“ä¸»è‰²ï¼Œæ„å»º AI åœºæ™¯é£æ ¼å‘é‡...");
  const mainColor = getAverageColor(bodyA);
  const compColor = getComplementColor(mainColor);
  log(`ğŸ¨ è§’è‰² A ä¸»è‰²ï¼šrgb(${mainColor.r}, ${mainColor.g}, ${mainColor.b})`);

  // Canvas
  const canvas = document.createElement("canvas");
  canvas.width = 480;
  canvas.height = 320;
  const ctx = canvas.getContext("2d");
  document.getElementById("preview").appendChild(canvas);

  log("ğŸŒ è°ƒç”¨ AI è§†é¢‘ç”Ÿæˆæ¥å£ï¼ˆæ¨¡æ‹Ÿï¼šåŸºäºéª¨éª¼ç»“æ„ + åœºæ™¯å‘é‡ç”Ÿæˆå…³é”®å¸§ï¼‰...");

  // MediaRecorder
  const stream = canvas.captureStream(30);
  let recorder;
  let chunks = [];

  try {
    recorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp9" });
  } catch (e) {
    recorder = new MediaRecorder(stream);
  }

  recorder.ondataavailable = e => {
    if (e.data && e.data.size > 0) chunks.push(e.data);
  };

  recorder.onstop = () => {
    log("ğŸ‰ AI è§†é¢‘ç”Ÿæˆå®Œæˆï¼ˆå½•åˆ¶ç»“æŸï¼‰ï¼");
    const blob = new Blob(chunks, { type: "video/webm" });
    const url = URL.createObjectURL(blob);

    document.getElementById("preview").innerHTML = `
      <h3>AI ç”Ÿæˆè§†é¢‘ç»“æœï¼š</h3>
      <video controls src="${url}"></video>
      <br><br>
      <a href="${url}" download="ai-shadow-video.webm">ç‚¹å‡»ä¸‹è½½ ai-shadow-video.webm</a>
    `;
  };

  chunks = [];
  recorder.start();
  log("ğŸ¥ å¼€å§‹å½•åˆ¶ AI çš®å½±åŠ¨ç”»ï¼ˆçº¦ 5 ç§’ï¼‰...");

  const recordDuration = 5000;
  const startTime = performance.now();

  function renderFrame(now) {
    const elapsed = now - startTime;
    const t = (elapsed / recordDuration) % 1;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1âƒ£ èƒŒæ™¯
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const grad = ctx.createRadialGradient(cx, cy, 40, cx, cy, 260);
    grad.addColorStop(0, rgbStr(compColor, 0.95));
    grad.addColorStop(0.45, rgbStr(mainColor, 0.85));
    grad.addColorStop(1, "rgba(5, 5, 15, 0.95)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const dots = 32;
    for (let j = 0; j < dots; j++) {
      const angle = (j / dots) * Math.PI * 2 + t * 2;
      const radius = 30 + (j * 6);
      const x = canvas.width / 2 + Math.cos(angle) * radius;
      const y = canvas.height / 2 + Math.sin(angle) * radius;
      const size = 2 + (j % 4);

      ctx.beginPath();
      ctx.fillStyle =
        j % 2 === 0
          ? rgbStr(mainColor, 0.18 + (j % 3) * 0.05)
          : rgbStr(compColor, 0.18 + (j % 3) * 0.05);
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }

    const baseY = canvas.height * 0.82;

    // A å›ºå®šåœ¨å·¦ä¾§ç•¥åä¸­
    const ax = canvas.width * 0.28;

    // B ä»å³å‘ä¸­é—´ç§»åŠ¨
    const bProgress = Math.min(1, t * 1.2);
    const bx = canvas.width * (0.9 - 0.4 * bProgress);

    // ç”» Aï¼ˆå…³èŠ‚æ‰‹è‡‚ï¼‰
    drawCharacterA(ctx, bodyA, armLeftA, armRightA, ax, baseY, t, 0.0);

    // ç”» Bï¼ˆæ•´ä½“ç§»åŠ¨ï¼‰
    drawCharacterB(ctx, charB, bx, baseY, t, Math.PI / 3);

    // å¯¹è¯å…‰å¸¦
    if (t > 0.3 && t < 0.9) {
      ctx.beginPath();
      const midY = baseY - canvas.height * 0.35;
      const opacity = 0.45 + Math.sin(t * Math.PI) * 0.2;
      ctx.strokeStyle = rgbStr(compColor, opacity);
      ctx.lineWidth = 3;
      ctx.moveTo(ax, midY);
      ctx.lineTo(bx, midY);
      ctx.stroke();
    }

    if (elapsed < recordDuration) {
      animId = requestAnimationFrame(renderFrame);
    } else {
      cancelAnimationFrame(animId);
      animId = null;
      recorder.stop();
      log("â¹ åœæ­¢å½•åˆ¶ï¼Œæ­£åœ¨ç”Ÿæˆè§†é¢‘æ–‡ä»¶...");
    }
  }

  animId = requestAnimationFrame(renderFrame);
}
</script>

</body>
</html>
