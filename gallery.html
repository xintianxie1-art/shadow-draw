function renderShadowPuppet(dataURL, canvasId) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext("2d");
  const img = new Image();

  img.onload = function () {
    const cw = canvas.width;
    const ch = canvas.height;

    // 1. 米黄色幕布背景 + 轻微竖向渐变
    const bg = ctx.createLinearGradient(0, 0, 0, ch);
    bg.addColorStop(0, "#fdf6e6");
    bg.addColorStop(1, "#f3e0c0");
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, cw, ch);

    // 2. 把原图画到一个离屏画布上，便于处理
    const off = document.createElement("canvas");
    off.width = cw;
    off.height = ch;
    const offCtx = off.getContext("2d");

    const scale = Math.min(cw / img.width, ch / img.height);
    const dw = img.width * scale;
    const dh = img.height * scale;
    const dx = (cw - dw) / 2;
    const dy = (ch - dh) / 2;

    offCtx.clearRect(0, 0, cw, ch);
    offCtx.drawImage(img, dx, dy, dw, dh);

    // 3. 把线稿提取成深棕色轮廓，背景弄成透明
    let imageData = offCtx.getImageData(0, 0, cw, ch);
    let d = imageData.data;

    for (let i = 0; i < d.length; i += 4) {
      const r = d[i];
      const g = d[i + 1];
      const b = d[i + 2];
      const a = d[i + 3];

      if (a < 10) {
        d[i + 3] = 0; // 完全透明，直接忽略
        continue;
      }

      const gray = 0.299 * r + 0.587 * g + 0.114 * b;

      if (gray < 230) {
        // 判定为线条区域：改成深棕色轮廓
        d[i] = 60;
        d[i + 1] = 30;
        d[i + 2] = 20;
        d[i + 3] = 255;
      } else {
        // 非线条：透明
        d[i + 3] = 0;
      }
    }
    offCtx.putImageData(imageData, 0, 0);

    // 4. 先画一层模糊的彩色影子（染色皮革感）
    ctx.save();
    ctx.filter = "blur(6px)";
    ctx.globalAlpha = 0.85;
    ctx.globalCompositeOperation = "multiply";
    ctx.drawImage(off, 0, 0);
    ctx.restore();

    // 5. 再叠加一层清晰轮廓
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.drawImage(off, 0, 0);
    ctx.restore();

    // 6. 在有内容的地方“打孔”做镂空
    const holeStep = 18; // 孔间距
    const radius = 2;    // 孔半径

    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = "rgba(0,0,0,1)";
    for (let y = radius; y < ch; y += holeStep) {
      for (let x = radius; x < cw; x += holeStep) {
        const pixel = ctx.getImageData(x, y, 1, 1).data;
        if (pixel[3] > 20) { // 只在有内容的地方打孔
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    ctx.restore();

    // 7. 加一点暗角，让中间更亮，像灯后面的幕布
    const vignette = ctx.createRadialGradient(
      cw / 2, ch / 2, Math.min(cw, ch) / 3,
      cw / 2, ch / 2, Math.max(cw, ch) / 1.1
    );
    vignette.addColorStop(0, "rgba(0,0,0,0)");
    vignette.addColorStop(1, "rgba(0,0,0,0.28)");
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, cw, ch);
  };

  img.src = dataURL;
}

